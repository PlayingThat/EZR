#version 450

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// weather textures
layout (rgba32f, binding = 0) uniform image3D outVolTex1;
layout (rgba32f, binding = 1) uniform image3D outVolTex2;
layout (rgba32f, binding = 2) uniform image3D outVolTex3;

// initial weather textures
layout (rgba32f, binding = 3) uniform image3D outVolTex4;
layout (rgba32f, binding = 4) uniform image3D outVolTex5;
layout (rgba32f, binding = 5) uniform image3D outVolTex6;

uniform float gridSizeXY;
uniform float gridSizeZ;

uniform float randomSeed;

// heat capacity of air at constant pressure in J / (kg * K)
const float cpd = 1004.5f;

// specific gas constant of dry air in J / (kg * K)
const float Rd = 287.058f;

// standard pressure in kPa
const float pz0 = 100000.0f;

float hash(int n)
{
    return fract(sin(float(n) + 1.951) * 43758.5453 + randomSeed);
}

float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

float perlin(vec3 p){
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);

    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = perm(b.xyxy);
    vec4 k2 = perm(k1.xyxy + b.zzww);

    vec4 c = k2 + a.zzzz;
    vec4 k3 = perm(c);
    vec4 k4 = perm(c + 1.0);

    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));

    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

    return o4.y * d.y + o4.x * (1.0 - d.y);
}

float noise(vec3 x)
{
    vec3 p = floor(x);
    vec3 f = fract(x);

    f = f*f*(vec3(3.0) - vec3(2.0) * f);
    float n = p.x + p.y*57.0 + 113.0*p.z;
    return mix(
    mix(
    mix(hash(int(n + 0.0)), hash(int(n + 1.0)), f.x),
    mix(hash(int(n + 57.0)), hash(int(n + 58.0)), f.x),
    f.y),
    mix(
    mix(hash(int(n + 113.0)), hash(int(n + 114.0)), f.x),
    mix(hash(int(n + 170.0)), hash(int(n + 171.0)), f.x),
    f.y),
    f.z);
}

float cells(vec3 p, float cellCount)
{
    vec3 pCell = p * cellCount;
    float d = 1.0e10;
    for (int xo = -1; xo <= 1; xo++)
    {
        for (int yo = -1; yo <= 1; yo++)
        {
            for (int zo = -1; zo <= 1; zo++)
            {
                vec3 tp = floor(pCell) + vec3(xo, yo, zo);

                tp = pCell - tp - noise(mod(tp, cellCount / 1.0));

                d = min(d, dot(tp, tp));
            }
        }
    }
    d = min(d, 1.0);
    d = max(d, 0.0f);

    return d;
}

float worleyNoise3D(vec3 p, float cellCount)
{
    return cells(p, cellCount);
}

float exnerFunction(float pressure)
{
    return pow(pressure / pz0, Rd / cpd);
}

void main()
{
    ivec3 pixel = ivec3(gl_GlobalInvocationID.xyz);

    vec3 uv = vec3(pixel.xy / gridSizeXY, pixel.z / gridSizeZ);
    vec3 suv = vec3(uv.x + 5.5, uv.y + 5.5, uv.z + 5.5);

    float qc = worleyNoise3D(suv, 2.8f);
    float qr = worleyNoise3D(suv, 3.8f);
    float qv = worleyNoise3D(suv, 5.0f);
    float coverage = perlin(suv * 4.0f);
    float pi = (1.0f + coverage / 20.0f); //* ((gridSizeZ - gl_GlobalInvocationID.z / 2) / (gridSizeZ));
    float ro = 0.9f + perlin(suv) / 5.0f;
    float theta = 270.0f + (20.0f / pi);

    // wind based on perlin noise
    float u = perlin(suv * 1.9f);
    float v = perlin(suv * 3.7f);
    float w = 0.0f;

    vec4 attributes1 = vec4(coverage, 0.0f, theta, ro);
    vec4 attributes2 = vec4(qc, qr, qv, pi);
    vec4 attributes3 = vec4(u, v, w, 0.0f);

    // save to weather texture
    imageStore(outVolTex1, pixel, attributes1);
    imageStore(outVolTex2, pixel, attributes2);
    imageStore(outVolTex3, pixel, attributes3);

    // save initial reference to texture
    imageStore(outVolTex4, pixel, attributes1);
    imageStore(outVolTex5, pixel, attributes2);
    imageStore(outVolTex6, pixel, attributes3);
}